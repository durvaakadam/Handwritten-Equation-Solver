<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Handwritten Equation Solver</title>
  <link href="https://fonts.googleapis.com/css2?family=Gloria+Hallelujah&display=swap" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <!-- Link external CSS -->
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}"></head>
<body>

<div class="container">
  <div class="left">
    <h1>Draw Equation</h1>
    <div class="canvas-wrapper">
      <canvas id="drawCanvas" width="400" height="220"></canvas>
    </div>
    <div class="buttons">
      <button id="predictBtn">Predict</button>
      <button id="clearBtn">Clear</button>
    </div>
    <div class="upload-section">
    </div>
  </div>
  
  <div class="right">
    <h1>Results</h1>
    <div class="results">
      <div>
        <label>Entered Equation</label>
        <input type="text" id="prediction" readonly placeholder="Prediction will appear here">
      </div>
      <div>
        <label>Formatted Equation</label>
        <input type="text" id="formatted" readonly placeholder="Equation formatted">
      </div>
      <div>
        <label>Result</label>
        <input type="text" id="result" readonly placeholder="Result will appear here">
      </div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");

// White background
ctx.fillStyle = "#fff";
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Drawing settings
ctx.lineWidth = 3;
ctx.lineCap = "round";
ctx.strokeStyle = "#2c3e50";

let drawing = false;

// Fix cursor offset on CSS-scaled canvas
function getMousePos(canvas, evt) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (evt.clientX - rect.left) * scaleX,
    y: (evt.clientY - rect.top) * scaleY
  };
}

// Drawing Events
canvas.addEventListener("mousedown", e => {
  drawing = true;
  const pos = getMousePos(canvas, e);
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);
});
canvas.addEventListener("mousemove", e => {
  if (!drawing) return;
  const pos = getMousePos(canvas, e);
  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
});
canvas.addEventListener("mouseup", () => drawing = false);
canvas.addEventListener("mouseleave", () => drawing = false);

// Buttons
document.getElementById("clearBtn").addEventListener("click", () => {
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
});

document.getElementById("predictBtn").addEventListener("click", () => sendCanvas());
document.getElementById("saveBtn").addEventListener("click", () => {
  const fileInput = document.getElementById("fileInput");
  if(fileInput.files.length > 0){
    const reader = new FileReader();
    reader.onload = e => sendImage(e.target.result);
    reader.readAsDataURL(fileInput.files[0]);
  } else {
    alert("Please select a file first!");
  }
});

// Send canvas image to server
function sendCanvas() {
  const dataURL = canvas.toDataURL("image/png");
  sendImage(dataURL);
}

// Common send function
function sendImage(dataURL){
  fetch("/predict", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ image: dataURL })
  })
  .then(res => res.json())
  .then(data => {
    if(data.error){
      alert("Error: " + data.error);
      return;
    }
    document.getElementById("prediction").value = data.prediction;
    document.getElementById("formatted").value = data.prediction; 
    document.getElementById("result").value = data.result;
  })
  .catch(err => alert("Request failed: " + err));
}
</script>

</body>
</html>
